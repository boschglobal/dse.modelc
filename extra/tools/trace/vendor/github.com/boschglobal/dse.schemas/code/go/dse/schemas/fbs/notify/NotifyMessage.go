// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package notify

import (
	flatbuffers "github.com/google/flatbuffers/go"
)

/// Notify Message.
/// (SimBus -> Model) Analog to ModelStart message.
/// (Model -> SimBus) Analog to ModelReady message.
type NotifyMessage struct {
	_tab flatbuffers.Table
}

func GetRootAsNotifyMessage(buf []byte, offset flatbuffers.UOffsetT) *NotifyMessage {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &NotifyMessage{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsNotifyMessage(buf []byte, offset flatbuffers.UOffsetT) *NotifyMessage {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &NotifyMessage{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *NotifyMessage) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *NotifyMessage) Table() flatbuffers.Table {
	return rcv._tab
}

/// Signal Vectors.
func (rcv *NotifyMessage) Signals(obj *SignalVector, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *NotifyMessage) SignalsLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// Signal Vectors.
/// Model Time.
/// (SimBus -> Model) From where the Model should start its execution step.
/// (Model -> SimBus) Indicates the reached and committed Model Time.
func (rcv *NotifyMessage) ModelTime() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Model Time.
/// (SimBus -> Model) From where the Model should start its execution step.
/// (Model -> SimBus) Indicates the reached and committed Model Time.
func (rcv *NotifyMessage) MutateModelTime(n float64) bool {
	return rcv._tab.MutateFloat64Slot(6, n)
}

/// Notify Time.
/// (SimBus -> Model) Indicates the "event" time for the contained signals.
/// (Model -> SimBus) Indicates the "event" time for the contained signals.
func (rcv *NotifyMessage) NotifyTime() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Notify Time.
/// (SimBus -> Model) Indicates the "event" time for the contained signals.
/// (Model -> SimBus) Indicates the "event" time for the contained signals.
func (rcv *NotifyMessage) MutateNotifyTime(n float64) bool {
	return rcv._tab.MutateFloat64Slot(8, n)
}

/// Schedule Time.
/// (SimBus -> Model) The expected (or anticipated) Stop Time for the execution step.
func (rcv *NotifyMessage) ScheduleTime() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Schedule Time.
/// (SimBus -> Model) The expected (or anticipated) Stop Time for the execution step.
func (rcv *NotifyMessage) MutateScheduleTime(n float64) bool {
	return rcv._tab.MutateFloat64Slot(10, n)
}

/// UID.
/// (Model -> SimBus) Indicate which Models are represented by this Notify Message.
func (rcv *NotifyMessage) ModelUid(j int) uint32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetUint32(a + flatbuffers.UOffsetT(j*4))
	}
	return 0
}

func (rcv *NotifyMessage) ModelUidLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// UID.
/// (Model -> SimBus) Indicate which Models are represented by this Notify Message.
func (rcv *NotifyMessage) MutateModelUid(j int, n uint32) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateUint32(a+flatbuffers.UOffsetT(j*4), n)
	}
	return false
}

/// Benchmarking.
/// (notify) Amount of time processing the Notify Message.
func (rcv *NotifyMessage) BenchNotifyTimeNs() uint64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.GetUint64(o + rcv._tab.Pos)
	}
	return 0
}

/// Benchmarking.
/// (notify) Amount of time processing the Notify Message.
func (rcv *NotifyMessage) MutateBenchNotifyTimeNs(n uint64) bool {
	return rcv._tab.MutateUint64Slot(14, n)
}

/// (model) Amount of time executing the Model (i.e. calling do_step()).
func (rcv *NotifyMessage) BenchModelTimeNs() uint64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		return rcv._tab.GetUint64(o + rcv._tab.Pos)
	}
	return 0
}

/// (model) Amount of time executing the Model (i.e. calling do_step()).
func (rcv *NotifyMessage) MutateBenchModelTimeNs(n uint64) bool {
	return rcv._tab.MutateUint64Slot(16, n)
}

func NotifyMessageStart(builder *flatbuffers.Builder) {
	builder.StartObject(7)
}
func NotifyMessageAddSignals(builder *flatbuffers.Builder, signals flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(signals), 0)
}
func NotifyMessageStartSignalsVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func NotifyMessageAddModelTime(builder *flatbuffers.Builder, modelTime float64) {
	builder.PrependFloat64Slot(1, modelTime, 0.0)
}
func NotifyMessageAddNotifyTime(builder *flatbuffers.Builder, notifyTime float64) {
	builder.PrependFloat64Slot(2, notifyTime, 0.0)
}
func NotifyMessageAddScheduleTime(builder *flatbuffers.Builder, scheduleTime float64) {
	builder.PrependFloat64Slot(3, scheduleTime, 0.0)
}
func NotifyMessageAddModelUid(builder *flatbuffers.Builder, modelUid flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(4, flatbuffers.UOffsetT(modelUid), 0)
}
func NotifyMessageStartModelUidVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func NotifyMessageAddBenchNotifyTimeNs(builder *flatbuffers.Builder, benchNotifyTimeNs uint64) {
	builder.PrependUint64Slot(5, benchNotifyTimeNs, 0)
}
func NotifyMessageAddBenchModelTimeNs(builder *flatbuffers.Builder, benchModelTimeNs uint64) {
	builder.PrependUint64Slot(6, benchModelTimeNs, 0)
}
func NotifyMessageEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
